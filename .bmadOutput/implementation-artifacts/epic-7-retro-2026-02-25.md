# Rétrospective — Epic 7 : Commandes Telegram Étendues — Contrôle Complet

**Date** : 2026-02-25
**Facilitateur** : Bob (Scrum Master)
**Epic** : 7 — Commandes Telegram Étendues
**FRs couvertes** : FR24, FR25, FR26, FR27
**Statut** : done (3/3 stories complétées)

---

## Participants

- Bob (Scrum Master) — Facilitateur
- Alice (Product Owner)
- Amelia (Dev Agent)
- Quinn (QA Engineer)
- taieb (Project Lead)

---

## Métriques de Livraison

| Métrique | Valeur |
|---|---|
| Stories livrées | 3/3 (100%) |
| Tests totaux | 200 (augmentation de 132 → 200, +68 tests) |
| Régressions | 0 |
| Issues code review | 8 identifiées, 7 fixées, 1 hors scope (M4) |
| Agents dev | claude-sonnet-4-6 (7.2), claude-opus-4-6 (7.1 fix, 7.3, review) |
| Incidents production | 0 |
| Dette technique ajoutée | 1 item (M4 — TimeProvider dans RecordSuccess/RecordFailure) |

---

## Stories Livrées

### Story 7.1 : Commandes /start et /stop — Contrôle du Scheduling
- **FRs** : FR24 (/start), FR25 (/stop)
- **Composants** : StartCommandHandler, StopCommandHandler, ExecutionStateService (SchedulingEnabled + persistance scheduling-state.json), SchedulerWorker (polling 5s)
- **Tests ajoutés** : ~15 (handlers + scheduling enabled/disabled + cancellation)

### Story 7.2 : Commande /history — Historique des Publications
- **FR** : FR26
- **Composants** : HistoryCommandHandler, HistoryManager.GetRecentEntriesAsync, MessageFormatter.FormatHistory
- **Tests ajoutés** : ~12 (handler + formatter + manager)

### Story 7.3 : Commande /schedule — Configuration Horaire via Telegram
- **FR** : FR27
- **Composants** : ScheduleCommandHandler, ExecutionStateService (ScheduleTime + persistance), SchedulerWorker (heure dynamique)
- **Tests ajoutés** : ~8 (handler + persistence + dynamic schedule)

---

## Ce Qui a Bien Fonctionné

### 1. Pattern CommandHandler cohérent
Les 4 nouveaux handlers (/start, /stop, /history, /schedule) suivent exactement le même pattern que les handlers MVP (/run, /status). L'architecture `ICommandHandler` + dispatch automatique via DI a prouvé sa solidité — aucune modification de `TelegramBotService.HandleUpdateAsync` n'a été nécessaire (sauf le message d'aide).

### 2. ExecutionStateService comme point central d'état
Le Singleton thread-safe avec `lock` a été étendu proprement pour 3 nouvelles responsabilités (SchedulingEnabled, ScheduleTime, persistance JSON). Le pattern d'écriture atomique (write-to-temp + rename) hérité de HistoryManager a été réutilisé avec succès.

### 3. Progression des tests (+68 en un epic)
De 132 à 200 tests, soit +51% de couverture. Tous les nouveaux composants ont des tests dédiés. Le pattern `FakeTimeProvider` + `TaskCompletionSource` pour les tests async s'est standardisé.

### 4. Code review adversariale efficace
La review a détecté 8 issues dont un test flaky (race condition), un SchedulerWorker qui ne réagissait pas immédiatement au /stop, et des story files désynchronisés. Ces problèmes n'auraient pas été visibles sans review systématique.

---

## Défis et Améliorations

### 1. Story 7.1 — Fichier story non mis à jour par le dev agent
Le fichier story 7.1 est resté en `ready-for-dev` avec toutes les tasks non cochées et un Dev Agent Record vide, alors que le code était commité. C'est un problème de process du dev agent qui ne met pas à jour le fichier story après implémentation.

**Action** : Inclure la mise à jour du story file dans les critères de "done" du dev agent.

### 2. Sprint-status désynchronisé
Le sprint-status pour story 7.3 indiquait `ready-for-dev` alors que le code était implémenté. La mise à jour du sprint-status n'est pas toujours effectuée par le dev agent.

**Action** : Le dev agent doit systématiquement mettre à jour le sprint-status en fin d'implémentation.

### 3. Test flaky — Race condition avec FakeTimeProvider
Le test `ExecuteAsync_WhenSchedulingDisabled_DoesNotRunCycle_UntilEnabled` utilisait `Task.Delay(50)` et `Task.Delay(200)` (délais arbitraires) au lieu de signaling déterministe. Ce pattern était déjà corrigé dans `SchedulerWorkerPollyTests` (story 5.2) via `SignalingFakeTimeProvider`, mais le learning n'a pas été appliqué au nouveau test.

**Leçon** : Les tests async doivent TOUJOURS utiliser le signaling déterministe (`TaskCompletionSource` + `CreateTimer` override), jamais des `Task.Delay` arbitraires.

### 4. SchedulerWorker — Check scheduling au mauvais endroit
Le check `GetSchedulingEnabled()` était positionné APRÈS le long `Task.Delay` du prochain run, ce qui signifie qu'un `/stop` envoyé pendant l'attente (potentiellement 12h+) ne prenait effet qu'après le cycle suivant. Déplacé avant le delay pour réactivité immédiate.

**Leçon** : Toujours penser à la réactivité UX — un `/stop` doit prendre effet immédiatement, pas après des heures d'attente.

### 5. Fakes à maintenir dans les tests
L'ajout de nouvelles méthodes à `IExecutionStateService` (GetScheduleTime, SetScheduleTime) a nécessité la mise à jour de 8+ fichiers de test contenant des fakes. C'est un coût croissant.

**Observation** : Acceptable pour l'instant (le nombre d'interfaces reste faible), mais à surveiller si l'interface grandit davantage.

---

## Suivi Rétrospective Epic 5

### Action Items Epic 5 — Bilan

| Action Item | Statut | Commentaire |
|---|---|---|
| Utiliser `CancellationToken.None` pour notifications en catch final | ✅ Appliqué | Pattern respecté dans SchedulerWorker |
| Tests d'intégration pour chaque composant Polly | ✅ Appliqué | SchedulerWorkerPollyTests toujours actifs |
| Auditer les champs readonly non utilisés | ✅ Appliqué | `_scheduleTime` readonly supprimé (devenu dynamique) |
| Spike POST /v1/bet-orders en production | ❌ Non adressé | 5ème report consécutif — bloquant pour la confiance production |
| SignalingFakeTimeProvider comme pattern standard | ⏳ Partiellement | Appliqué dans PollyTests, mais pas dans les nouveaux tests 7.1 (corrigé en review) |

**Bilan** : 3/5 appliqués, 1 partiellement, 1 non adressé. Le spike API reste le point noir récurrent.

---

## Dette Technique

| Item | Sévérité | Description |
|---|---|---|
| M4 — TimeProvider dans RecordSuccess/RecordFailure | LOW | `ExecutionStateService` utilise `DateTimeOffset.UtcNow` au lieu de `TimeProvider` injecté — non testable avec FakeTimeProvider. Hors scope epic 7. |
| Spike POST /v1/bet-orders | HIGH | Non validé en production depuis epic 3. Risque : le cycle de publication peut échouer silencieusement en prod. |

---

## Insights Clés

1. **Le pattern CommandHandler scale bien** : 6 commandes Telegram implémentées sans modifier le dispatch. L'architecture DI + `IEnumerable<ICommandHandler>` est validée pour le long terme.

2. **La persistance JSON simpliste suffit** : `scheduling-state.json` avec écriture atomique couvre les besoins de persistance d'état sans base de données. Pattern prouvé sur 2 stories (7.1 et 7.3).

3. **Les code reviews adversariales trouvent des vrais bugs** : Le test flaky et le scheduling check mal positionné n'auraient pas été détectés autrement. Le ROI de la review est très positif.

4. **La synchronisation story file / sprint-status est fragile** : 2 désynchronisations sur 3 stories. Le dev agent doit intégrer cette mise à jour dans son workflow.

---

## Préparation Epic 8 : Gestion des Tipsters via Telegram

### Preview
- **2 stories** : `/tipsters` (consulter liste) et `/tipsters add|remove` (CRUD)
- **FRs** : FR28, FR29, FR30
- **Dépendances Epic 7** : Pattern CommandHandler validé, dispatch automatique prêt

### Préparation Critique
Aucun bloqueur technique. Les patterns établis (CommandHandler, DI, tests) s'appliquent directement.

### Points d'Attention
1. **TipsterService** doit être étendu (pas remplacé) pour supporter CRUD — l'architecture le spécifie explicitement
2. **Écriture atomique de `tipsters.json`** — réutiliser le pattern write-to-temp + rename de HistoryManager
3. **Parsing d'arguments complexes** — `/tipsters add <lien>` et `/tipsters remove <lien>` nécessitent un parsing multi-niveaux (sous-commande + argument)

### Pas de Changement Significatif Détecté
Rien dans l'epic 7 ne remet en question le plan de l'epic 8. Le plan est valide tel quel.

---

## Action Items

### Process
1. **Dev agent : mettre à jour le story file en fin d'implémentation**
   - Owner : taieb (configuration dev agent workflow)
   - Critère : Status, tasks cochées, Dev Agent Record rempli avant passage en `review`

2. **Dev agent : mettre à jour sprint-status.yaml systématiquement**
   - Owner : taieb (configuration dev agent workflow)
   - Critère : Sprint-status reflète le statut réel de chaque story

### Technique
3. **Pattern standard : SignalingFakeTimeProvider pour tous les tests async avec FakeTimeProvider**
   - Owner : Amelia (Dev)
   - Critère : Aucun `Task.Delay(N)` comme mécanisme de synchronisation dans les tests

4. **Spike POST /v1/bet-orders — URGENCE**
   - Owner : taieb
   - Critère : Un test réel (ou validation manuelle documentée) du endpoint de publication
   - Note : 5ème report consécutif. Doit être traité avant tout déploiement Phase 2.

### Documentation
5. **Documenter le pattern de persistance JSON atomique dans project-context.md**
   - Owner : Amelia (Dev)
   - Critère : Pattern documenté avec exemple code (scheduling-state.json, history.json, tipsters.json)

---

## Engagements de l'Équipe

- Tous les tests async utilisent du signaling déterministe (pas de `Task.Delay` arbitraire)
- Le dev agent met à jour story file + sprint-status comme partie intégrante du workflow
- Le spike API est adressé avant le démarrage de l'epic 8 en production

---

## Prochaines Étapes

1. Exécuter les 5 action items ci-dessus
2. Commencer Epic 8 (Gestion des Tipsters) quand prêt
3. Revoir les action items au prochain standup

---

_Rétrospective facilitée par Bob (Scrum Master) — 2026-02-25_
